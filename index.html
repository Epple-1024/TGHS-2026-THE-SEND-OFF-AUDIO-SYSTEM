<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TG SENIOR SEND-OFF 2026 CONSOLE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            user-select: none; 
            -webkit-user-select: none; 
            min-height: 100vh;
            background-color: #050505;
            color: #e5e5e5;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .tabular-nums { font-variant-numeric: tabular-nums; }
        .hidden-visually { display: none !important; }
        .flex-center { display: flex; justify-content: center; align-items: center; }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

        .scene-btn { transition: all 0.3s ease; border-bottom: 2px solid transparent; opacity: 0.4; letter-spacing: 0.1em; }
        .scene-btn.active { opacity: 1; border-bottom-color: #3b82f6; color: #fff; text-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        
        .missile-switch { position: relative; display: inline-block; width: 100px; height: 52px; }
        .missile-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #1f2937; transition: .4s; border-radius: 9999px; border: 2px solid #374151; }
        .slider:before { position: absolute; content: ""; height: 44px; width: 44px; left: 3px; bottom: 2px; background-color: #9ca3af; transition: .4s; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .missile-switch input:checked + .slider { background: repeating-linear-gradient(45deg, #7f1d1d, #7f1d1d 10px, #991b1b 10px, #991b1b 20px); border-color: #ef4444; }
        .missile-switch input:checked + .slider:before { transform: translateX(46px); background-color: #fff; }

        .locked-btn { background-color: #111 !important; color: #444 !important; border: 1px solid #333; cursor: not-allowed; box-shadow: none !important; }

        #visualizer { position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; z-index: 0; pointer-events: none; opacity: 0.5; mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0)); -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0)); }

        #cinema-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: #000; z-index: 100; 
            display: none; flex-direction: column; justify-content: center; align-items: center;
            cursor: none; 
        }
        #cinema-overlay.active { display: flex; }

        #log-window {
            position: fixed; bottom: 50px; left: 10px; width: 300px; height: 150px;
            background: rgba(0,0,0,0.8); border: 1px solid #333; border-radius: 4px;
            font-size: 10px; overflow-y: auto; padding: 5px; z-index: 20;
            display: none;
        }
        #log-window.visible { display: block; }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
        .log-time { color: #666; margin-right: 5px; }
    </style>
</head>
<body class="flex flex-col items-center py-10">

    <canvas id="visualizer"></canvas>

    <div class="fixed top-0 left-0 w-full h-12 bg-gray-900/80 backdrop-blur border-b border-gray-800 flex items-center justify-between px-6 z-40 text-xs font-mono uppercase tracking-widest">
        <div class="flex items-center gap-4">
            <span class="text-gray-400">TG SENIOR SEND-OFF 2026</span>
            <span class="text-emerald-500">SYSTEM ONLINE</span>
        </div>
        <div class="flex items-center gap-6">
            <div id="status-net" class="flex items-center gap-2 text-gray-400"><span>NET:</span> <span id="val-net" class="text-white">CHECKING</span></div>
            <div id="status-batt" class="flex items-center gap-2 text-gray-400"><span>PWR:</span> <span id="val-batt" class="text-white">--%</span></div>
            <div class="flex items-center gap-2 text-gray-400 border-l border-gray-700 pl-6"><span>TIME:</span> <span id="val-clock" class="text-xl text-white font-bold tabular-nums">00:00:00</span></div>
        </div>
    </div>

    <div class="w-full max-w-5xl px-4 mt-12 z-10 flex flex-col gap-12 mb-20">

        <div class="flex flex-col items-center w-full">
            <div class="flex gap-12 mb-8">
                <button id="tab-entrance" class="scene-btn active text-xl font-bold" onclick="switchScene('ENTRANCE')">ENTRANCE</button>
                <button id="tab-exit" class="scene-btn text-xl font-bold" onclick="switchScene('EXIT')">EXIT</button>
            </div>

            <div id="dashboard-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 w-full p-6 border border-gray-800 rounded-xl bg-gray-900/40 backdrop-blur-sm transition-all duration-300">
                <div class="flex flex-col border-r border-gray-800">
                    <span class="text-gray-500 text-[10px] uppercase tracking-widest">Total Elapsed</span>
                    <span id="disp-total" class="text-4xl font-mono tabular-nums text-white">00:00.0</span>
                </div>
                <div class="flex flex-col border-r border-gray-800">
                    <span class="text-gray-500 text-[10px] uppercase tracking-widest">Current Cycle</span>
                    <span id="disp-loop" class="text-4xl font-mono tabular-nums text-blue-400"># --</span>
                </div>
                <div id="container-limit" class="flex flex-col border-r border-gray-800">
                    <span class="text-gray-500 text-[10px] uppercase tracking-widest text-rose-400">Decision Window</span>
                    <span id="disp-limit" class="text-4xl font-mono tabular-nums text-gray-600">--:--.-</span>
                </div>
                <div class="flex flex-col">
                    <span id="label-remain" class="text-gray-500 text-[10px] uppercase tracking-widest">Cycle Remaining</span>
                    <span id="disp-remain" class="text-4xl font-mono tabular-nums text-emerald-500">--:--.-</span>
                </div>
            </div>

            <div class="mt-4 text-center opacity-70">
                <p id="music-info" class="text-gray-300 text-xs font-mono tracking-wide"></p>
            </div>

            <div class="flex flex-col gap-4 w-full max-w-lg mt-8 items-center h-32 relative">
                <button id="btn-load" class="w-full h-24 bg-slate-800 hover:bg-slate-700 text-blue-100 rounded-xl text-xl font-bold tracking-widest transition border border-slate-600 shadow-lg flex-center">
                    INITIALIZE AUDIO
                </button>
                <button id="btn-start" disabled class="hidden-visually w-full h-24 bg-emerald-900 hover:bg-emerald-800 text-white rounded-xl text-3xl font-bold tracking-widest transition shadow-[0_0_30px_rgba(6,95,70,0.5)] disabled:opacity-20 flex-center">
                    PLAY AUDIO
                </button>
                <button id="btn-finish" disabled class="hidden-visually locked-btn w-full h-24 rounded-xl text-3xl font-bold tracking-widest transition duration-200 flex-center">
                    TRIGGER FINALE
                </button>
                <div id="safety-container" class="hidden-visually w-full h-24 flex-center gap-6 bg-gray-900/50 rounded-xl border border-gray-800">
                    <span class="text-xs text-gray-500 tracking-widest uppercase w-20 text-right">SAFETY</span>
                    <label class="missile-switch">
                        <input type="checkbox" id="safety-toggle">
                        <span class="slider"></span>
                    </label>
                    <span id="safety-status" class="text-xs font-bold tracking-widest uppercase text-emerald-600 w-20 text-left">SECURE</span>
                </div>
                
                <button id="btn-resume" class="hidden-visually absolute -right-48 top-0 w-32 h-24 bg-rose-900/80 hover:bg-rose-700 text-white border-2 border-rose-500 rounded-lg text-xs font-bold animate-pulse flex flex-col items-center justify-center z-50">
                    <span>⚠️ EMERGENCY</span>
                    <span class="text-lg">RESUME</span>
                </button>
            </div>
        </div>

        <div class="w-full h-px bg-gray-800 my-4"></div>

        <div class="flex flex-col items-center w-full">
            <h2 class="text-gray-500 text-xs tracking-[0.3em] mb-4 uppercase">Video Presentation Manager</h2>
            <div class="flex gap-4 items-end bg-gray-900/30 p-6 rounded-xl border border-gray-800">
                <div class="flex flex-col"><label class="text-xs text-gray-500 mb-1">DURATION (MIN)</label><input type="number" id="video-min" value="32" class="bg-black border border-gray-700 text-white text-2xl w-20 p-2 text-center rounded font-mono focus:border-blue-500 outline-none"></div>
                <div class="flex flex-col"><label class="text-xs text-gray-500 mb-1">SEC</label><input type="number" id="video-sec" value="00" class="bg-black border border-gray-700 text-white text-2xl w-20 p-2 text-center rounded font-mono focus:border-blue-500 outline-none"></div>
                <button id="btn-cinema" class="h-12 px-8 bg-indigo-900 hover:bg-indigo-800 text-white font-bold tracking-widest rounded transition border border-indigo-700 ml-4">START CINEMA MODE</button>
            </div>
            <p class="text-[10px] text-gray-600 mt-2">Starts countdown & blacks out screen. Double-click to exit.</p>
        </div>
    </div>

    <div class="fixed bottom-4 left-4 z-50">
        <button onclick="toggleLog()" class="text-[10px] text-gray-500 hover:text-white border border-gray-800 px-3 py-1 rounded bg-black">SYSTEM LOG</button>
    </div>
    <div id="log-window"></div>

    <div id="cinema-overlay">
        <div class="text-gray-600 text-xs tracking-[0.5em] mb-8">PRESENTATION IN PROGRESS</div>
        <div id="cinema-timer" class="text-8xl md:text-9xl font-bold text-gray-200 font-mono tabular-nums tracking-widest">00:00</div>
        <div class="mt-8 text-gray-700 text-xs font-mono">DOUBLE CLICK ANYWHERE TO EXIT</div>
        <div class="absolute bottom-10 flex gap-8 text-gray-800 font-mono text-xs"><span id="cinema-clock">00:00:00</span><span id="cinema-batt">PWR: --%</span></div>
    </div>

    <div class="fixed bottom-4 right-4 z-50">
        <button onclick="if(confirm('RESET SYSTEM?')) location.reload()" class="text-[10px] text-red-900 hover:text-red-500 border border-red-900/30 px-3 py-1 rounded bg-black">HARD RESET</button>
    </div>

    <script>
        // CONFIG
        const SCENE_CONFIG = {
            ENTRANCE: { hasBridge: true, junctionPoint: 64.8, musicTitle: "UE WO MUITE ARUKOU (Piano & String Qt. Mix)", musicArtist: "Comp. Hachidai Nakamura / Mix. K.Eba", files: { intro: './audio/intro.m4a', loop: './audio/loop.m4a', bridge: './audio/bridge.m4a', outro: './audio/outro.m4a' } },
            EXIT: { hasBridge: false, junctionPoint: 0.1, musicTitle: "SANGATSU KOKONOKA (March 9th)", musicArtist: "Artist: Remioromen / Edit. K.Eba", files: { intro: './audio/exit_intro.m4a', loop: './audio/exit_loop.m4a', bridge: './audio/exit_outro.m4a', outro: './audio/exit_outro.m4a' } }
        };

        // GLOBAL STATE
        let currentScene = 'ENTRANCE';
        let audioCtx;
        let buffers = {};
        let nodes = { intro: null, loop: null, bridge: null, outro: null };
        let analyser = null; 
        
        let globalStartTime = 0;
        let loopStartTime = 0; 
        let isPlaying = false;
        let isLocked = false; 
        let currentPhase = "STANDBY"; 
        let finishScheduledTime = 0; 
        let wakeLock = null;
        
        // --- RECOVERY STATE (The Phoenix Logic) ---
        let lastKnownState = {
            active: false,
            phase: 'STANDBY',
            elapsedTotal: 0,
            elapsedInPhase: 0,
            scene: 'ENTRANCE'
        };

        // ELEMENTS
        const els = {
            btnLoad: document.getElementById('btn-load'),
            btnStart: document.getElementById('btn-start'),
            btnFinish: document.getElementById('btn-finish'),
            btnResume: document.getElementById('btn-resume'), // New
            safetyContainer: document.getElementById('safety-container'),
            safetyToggle: document.getElementById('safety-toggle'),
            safetyStatus: document.getElementById('safety-status'),
            dashboardGrid: document.getElementById('dashboard-grid'),
            containerLimit: document.getElementById('container-limit'),
            dispTotal: document.getElementById('disp-total'),
            dispLoop: document.getElementById('disp-loop'),
            dispRemain: document.getElementById('disp-remain'),
            dispLimit: document.getElementById('disp-limit'),
            labelRemain: document.getElementById('label-remain'),
            musicInfo: document.getElementById('music-info'),
            tabEntrance: document.getElementById('tab-entrance'),
            tabExit: document.getElementById('tab-exit'),
            canvas: document.getElementById('visualizer'),
            valClock: document.getElementById('val-clock'),
            valBatt: document.getElementById('val-batt'),
            valNet: document.getElementById('val-net'),
            btnCinema: document.getElementById('btn-cinema'),
            cinemaOverlay: document.getElementById('cinema-overlay'),
            cinemaTimer: document.getElementById('cinema-timer'),
            logWindow: document.getElementById('log-window'),
            videoMin: document.getElementById('video-min'),
            videoSec: document.getElementById('video-sec'),
            cinemaClock: document.getElementById('cinema-clock'),
            cinemaBatt: document.getElementById('cinema-batt')
        };

        updateSceneUI();
        initSystemMonitoring();

        // --- MONITORING & LOGGING ---
        function initSystemMonitoring() {
            setInterval(() => {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
                els.valClock.innerText = timeStr;
                els.cinemaClock.innerText = timeStr;
            }, 1000);
            function updateNet() { els.valNet.innerText = navigator.onLine ? "ONLINE" : "OFFLINE"; els.valNet.className = navigator.onLine ? "text-white" : "text-red-500 animate-pulse"; if(!navigator.onLine) logAction("NET LOST"); }
            window.addEventListener('online', updateNet); window.addEventListener('offline', updateNet); updateNet();
            if ('getBattery' in navigator) {
                navigator.getBattery().then(batt => {
                    function updateBatt() {
                        const level = Math.floor(batt.level * 100);
                        els.valBatt.innerText = `${level}%${batt.charging ? ' CHG' : ''}`;
                        els.cinemaBatt.innerText = `PWR: ${level}%`;
                        els.valBatt.className = (level < 20 && !batt.charging) ? 'text-red-500' : 'text-white';
                    }
                    batt.addEventListener('levelchange', updateBatt); batt.addEventListener('chargingchange', updateBatt); updateBatt();
                });
            }
        }
        function logAction(msg) {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            els.logWindow.prepend(Object.assign(document.createElement('div'), { className: 'log-entry', innerHTML: `<span class="log-time">[${time}]</span> ${msg}` }));
        }
        window.toggleLog = function() { els.logWindow.classList.toggle('visible'); };

        // --- CINEMA ---
        let cinemaInterval = null, cinemaSeconds = 0;
        els.btnCinema.addEventListener('click', () => {
            cinemaSeconds = (parseInt(els.videoMin.value)||0)*60 + (parseInt(els.videoSec.value)||0);
            els.cinemaOverlay.classList.add('active');
            requestWakeLock();
            logAction("CINEMA MODE START");
            updateCinemaTimer();
            if(cinemaInterval) clearInterval(cinemaInterval);
            cinemaInterval = setInterval(() => { cinemaSeconds--; if(cinemaSeconds < 0) cinemaSeconds = 0; updateCinemaTimer(); }, 1000);
        });
        function updateCinemaTimer() { els.cinemaTimer.innerText = `${Math.floor(cinemaSeconds/60).toString().padStart(2,'0')}:${(cinemaSeconds%60).toString().padStart(2,'0')}`; }
        els.cinemaOverlay.addEventListener('dblclick', () => { els.cinemaOverlay.classList.remove('active'); clearInterval(cinemaInterval); logAction("CINEMA MODE END"); });

        // --- AUDIO CORE ---
        const canvasCtx = els.canvas.getContext('2d');
        let dataArray;
        function setupVisualizer() {
            analyser = audioCtx.createAnalyser(); analyser.fftSize = 256; dataArray = new Uint8Array(analyser.frequencyBinCount);
            window.addEventListener('resize', () => { els.canvas.width = window.innerWidth; els.canvas.height = 100; });
            els.canvas.width = window.innerWidth; els.canvas.height = 100;
        }
        function drawVisualizer() {
            if (!isPlaying || !analyser) return;
            requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(dataArray);
            canvasCtx.clearRect(0, 0, els.canvas.width, els.canvas.height);
            const barWidth = (els.canvas.width / dataArray.length) * 2.5; let x = 0;
            for(let i = 0; i < dataArray.length; i++) {
                const h = dataArray[i] / 2.5;
                const g = canvasCtx.createLinearGradient(0, 100, 0, 100-h); g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#1e293b');
                canvasCtx.fillStyle = g; canvasCtx.fillRect(x, 100-h, barWidth, h); x += barWidth + 2;
            }
        }

        // --- RESUME LOGIC (The Fix) ---
        els.btnResume.addEventListener('click', () => {
            if(!lastKnownState.active || !audioCtx) return;
            
            // 1. Restore State
            if (audioCtx.state === 'suspended') audioCtx.resume();
            currentScene = lastKnownState.scene;
            currentPhase = lastKnownState.phase;
            const now = audioCtx.currentTime;
            
            logAction(`!!! EMERGENCY RESUME: ${currentPhase} at ${lastKnownState.elapsedInPhase.toFixed(2)}s !!!`);

            // 2. Re-calculate Global Times to match the resume point
            //    If we are at 10s of Intro, globalStart should be (now - 10s)
            
            const prefix = `${currentScene}_`;
            
            if (currentPhase === 'INTRO') {
                globalStartTime = now - lastKnownState.elapsedInPhase;
                // Restart Intro from offset
                nodes.intro = audioCtx.createBufferSource(); nodes.intro.buffer = buffers[prefix+'intro'];
                nodes.intro.connect(analyser); analyser.connect(audioCtx.destination);
                nodes.intro.start(now, lastKnownState.elapsedInPhase);
                
                // Queue Loop
                const introDur = buffers[prefix+'intro'].duration;
                loopStartTime = globalStartTime + introDur;
                nodes.loop = audioCtx.createBufferSource(); nodes.loop.buffer = buffers[prefix+'loop'];
                nodes.loop.loop = true; nodes.loop.connect(analyser); analyser.connect(audioCtx.destination);
                nodes.loop.start(loopStartTime);

                // Set timeout for phase change
                const remain = introDur - lastKnownState.elapsedInPhase;
                setTimeout(() => { if(currentPhase === 'INTRO') currentPhase = 'LOOP'; }, remain * 1000);

            } else if (currentPhase === 'LOOP') {
                // Determine total elapsed in loop
                const loopDur = buffers[prefix+'loop'].duration;
                // Recover exact loop position
                const currentPos = lastKnownState.elapsedInPhase; // this is pos within one loop cycle? No, in updateDashboard I'll save pos
                
                // Note: dashboard logic uses loopStartTime. 
                // We need loopStartTime to be such that (now - loopStartTime) % duration == savedPos
                // Easier: Set loopStartTime so that (now - loopStartTime) = savedTotalLoopElapsed
                // Wait, simply restarting the loop source at offset is easier.
                
                nodes.loop = audioCtx.createBufferSource(); nodes.loop.buffer = buffers[prefix+'loop'];
                nodes.loop.loop = true; nodes.loop.connect(analyser); analyser.connect(audioCtx.destination);
                
                // Start with offset
                // loopNode.start(when, offset)
                nodes.loop.start(now, lastKnownState.elapsedInPhase);
                
                // Re-align global time
                // We don't know exact total elapsed from start, but we can approximate for display
                // For logic, we need loopStartTime.
                // dashboard: const loopElapsed = now - loopStartTime;
                // We want loopElapsed to be X.xx where X % dur = offset.
                // Let's assume we are in the same loop cycle count as before? Too complex.
                // Simplified: Reset loopStartTime so that it matches the offset exactly (Cycle 1)
                // This might reset the cycle count to #1, but the audio will be seamless.
                
                loopStartTime = now - lastKnownState.elapsedInPhase;
                const introDur = buffers[prefix+'intro'].duration;
                globalStartTime = loopStartTime - introDur;

            } 
            // Note: Recovering Bridge/Outro is rare/short, usually not needed. If needed, logic is similar.

            isPlaying = true;
            hideElement(els.btnStart);
            showElement(els.btnFinish);
            showElement(els.safetyContainer);
            hideElement(els.btnResume); // Hide self
            drawVisualizer();
            requestAnimationFrame(updateDashboard);
        });

        // --- Standard Logic ---
        function formatTime(sec) { if(sec<0)sec=0; return `${Math.floor(sec/60).toString().padStart(2,'0')}:${Math.floor(sec%60).toString().padStart(2,'0')}.${Math.floor((sec%1)*10)}`; }
        function updateSceneUI() { const c=SCENE_CONFIG[currentScene]; els.musicInfo.innerHTML = `<span class="text-white font-bold">${c.musicTitle}</span><br>${c.musicArtist}`; if(c.hasBridge){els.dashboardGrid.classList.add('md:grid-cols-4');els.dashboardGrid.classList.remove('md:grid-cols-3');els.containerLimit.classList.remove('hidden','md:hidden');els.containerLimit.classList.add('flex');}else{els.dashboardGrid.classList.remove('md:grid-cols-4');els.dashboardGrid.classList.add('md:grid-cols-3');els.containerLimit.classList.remove('flex');els.containerLimit.classList.add('hidden','md:hidden');} }
        async function requestWakeLock() { try{if('wakeLock' in navigator)wakeLock=await navigator.wakeLock.request('screen');}catch(e){} }
        function showElement(el) { el.classList.remove('hidden-visually'); el.classList.add('flex'); }
        function hideElement(el) { el.classList.add('hidden-visually'); el.classList.remove('flex'); }
        
        els.safetyToggle.addEventListener('change', (e) => { els.btnFinish.disabled = !e.target.checked; els.btnFinish.classList.toggle('locked-btn', !e.target.checked); els.btnFinish.classList.toggle('bg-rose-900', e.target.checked); els.safetyStatus.innerText = e.target.checked ? "ARMED" : "SECURE"; els.safetyStatus.className = e.target.checked ? "text-rose-500 animate-pulse font-bold text-xs" : "text-emerald-600 font-bold text-xs"; if(e.target.checked) logAction("SAFETY OFF"); });
        function resetSafety() { els.safetyToggle.checked = false; els.btnFinish.disabled = true; els.btnFinish.classList.add('locked-btn'); els.btnFinish.classList.remove('bg-rose-900'); els.safetyStatus.innerText = "SECURE"; els.safetyStatus.className = "text-emerald-600 font-bold text-xs"; hideElement(els.btnStart); hideElement(els.btnFinish); hideElement(els.safetyContainer); showElement(els.btnLoad); hideElement(els.btnResume); }
        window.switchScene = (s) => { if(isPlaying||isLocked)return; currentScene=s; els.tabEntrance.classList.toggle('active', s==='ENTRANCE'); els.tabExit.classList.toggle('active', s==='EXIT'); updateSceneUI(); softResetUI(); logAction("SCENE: "+s); };
        function softResetUI() { els.dispTotal.innerText="00:00.0"; els.dispLoop.innerText="# --"; els.dispLimit.innerText="--:--.-"; els.dispRemain.innerText="--:--.-"; resetSafety(); if(audioCtx){ hideElement(els.btnLoad); showElement(els.btnStart); } }

        els.btnLoad.addEventListener('click', async () => {
            try {
                await requestWakeLock();
                els.tabEntrance.disabled=true; els.tabExit.disabled=true;
                audioCtx = new AudioContext(); setupVisualizer();
                els.btnLoad.innerText = "LOADING..."; els.btnLoad.disabled=true;
                for(const s of ['ENTRANCE','EXIT']) for(const [k,u] of Object.entries(SCENE_CONFIG[s].files)) buffers[`${s}_${k}`] = await audioCtx.decodeAudioData(await (await fetch(u)).arrayBuffer());
                logAction("ASSETS LOADED");
                hideElement(els.btnLoad); showElement(els.btnStart); els.btnStart.disabled=false; els.tabEntrance.disabled=false; els.tabExit.disabled=false;
            } catch(e) { alert(e); els.btnLoad.innerText="RETRY"; els.btnLoad.disabled=false; els.tabEntrance.disabled=false; els.tabExit.disabled=false; }
        });

        els.btnStart.addEventListener('click', async () => {
            if(audioCtx.state==='suspended') audioCtx.resume();
            await requestWakeLock();
            isPlaying=true; els.tabEntrance.disabled=true; els.tabExit.disabled=true; els.tabEntrance.classList.add('opacity-20'); els.tabExit.classList.add('opacity-20');
            
            const now = audioCtx.currentTime;
            globalStartTime = now;
            currentPhase = "INTRO";
            
            const p = `${currentScene}_`;
            nodes.intro = audioCtx.createBufferSource(); nodes.intro.buffer=buffers[p+'intro']; nodes.intro.connect(analyser); analyser.connect(audioCtx.destination); nodes.intro.start(now);
            nodes.loop = audioCtx.createBufferSource(); nodes.loop.buffer=buffers[p+'loop']; nodes.loop.loop=true; nodes.loop.connect(analyser); analyser.connect(audioCtx.destination); 
            const iDur = buffers[p+'intro'].duration;
            loopStartTime = now + iDur;
            nodes.loop.start(loopStartTime);
            
            logAction("PLAY START");
            hideElement(els.btnStart); showElement(els.btnFinish); showElement(els.safetyContainer); drawVisualizer();
            setTimeout(() => { if(currentPhase==='INTRO') currentPhase='LOOP'; }, iDur*1000);
            requestAnimationFrame(updateDashboard);
        });

        els.btnFinish.addEventListener('click', () => {
            if(els.btnFinish.disabled) return;
            els.btnFinish.disabled=true; els.safetyToggle.disabled=true; els.btnFinish.classList.add('locked-btn'); els.btnFinish.classList.remove('bg-rose-900');
            logAction("FINISH TRIGGERED");
            const now=audioCtx.currentTime; const c=SCENE_CONFIG[currentScene]; const p=`${currentScene}_`;
            const lDur=buffers[p+'loop'].duration; const el=now-loopStartTime;
            let cnt=(el<0)?0:Math.floor(el/lDur); let pos=(el<0)?0:el%lDur;
            let tx;

            if(c.hasBridge && pos < c.junctionPoint) {
                currentPhase="WAITING_BRIDGE"; tx=loopStartTime+(cnt*lDur)+c.junctionPoint; finishScheduledTime=tx;
                nodes.loop.stop(tx);
                nodes.bridge=audioCtx.createBufferSource(); nodes.bridge.buffer=buffers[p+'bridge']; nodes.bridge.connect(analyser); analyser.connect(audioCtx.destination); nodes.bridge.start(tx);
                nodes.bridge.onended=handleComplete;
                setTimeout(()=>{currentPhase="BRIDGE"}, (tx-now)*1000);
            } else {
                currentPhase="WAITING_OUTRO"; tx=loopStartTime+((cnt+1)*lDur); finishScheduledTime=tx;
                nodes.loop.stop(tx);
                nodes.outro=audioCtx.createBufferSource(); nodes.outro.buffer=buffers[p+'outro']; nodes.outro.connect(analyser); analyser.connect(audioCtx.destination); nodes.outro.start(tx);
                nodes.outro.onended=handleComplete;
                setTimeout(()=>{currentPhase="OUTRO"}, (tx-now)*1000);
            }
        });

        function handleComplete() { currentPhase="FINISHED"; isPlaying=false; isLocked=true; logAction("COMPLETE"); setTimeout(()=>{isLocked=false; els.tabEntrance.disabled=false; els.tabExit.disabled=false; els.tabEntrance.classList.remove('opacity-20'); els.tabExit.classList.remove('opacity-20'); els.safetyToggle.disabled=false; softResetUI();},3000); }

        function updateDashboard() {
            if (!isPlaying) return;
            const now = audioCtx.currentTime;
            
            // --- STATE RECORDER for RESUME ---
            // Only tracking Intro and Loop for recovery (Bridge/Outro are too short/late to matter usually)
            if (currentPhase === 'INTRO') {
                lastKnownState = { active: true, scene: currentScene, phase: 'INTRO', elapsedInPhase: now - globalStartTime };
            } else if (currentPhase === 'LOOP') {
                const prefix = `${currentScene}_`;
                const lDur = buffers[prefix+'loop'].duration;
                const totalLoopElapsed = now - loopStartTime;
                const pos = totalLoopElapsed % lDur;
                lastKnownState = { active: true, scene: currentScene, phase: 'LOOP', elapsedInPhase: pos };
            }
            // ---------------------------------

            // Detect unexpected suspension (Sleep check)
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                // Show RESUME button
                showElement(els.btnResume);
                // Don't update UI numbers while suspended
                requestAnimationFrame(updateDashboard);
                return;
            } else {
                // Hide if running fine
                hideElement(els.btnResume);
            }

            const c = SCENE_CONFIG[currentScene]; const p = `${currentScene}_`;
            if(!buffers[p+'loop']) return;
            const lDur = buffers[p+'loop'].duration;

            els.dispTotal.innerText = formatTime(now - globalStartTime);

            if (currentPhase === "INTRO") {
                els.dispLoop.innerText="# --"; els.dispLimit.innerText="WAIT"; els.dispRemain.innerText=formatTime((globalStartTime+buffers[p+'intro'].duration)-now);
            } else if (currentPhase === "LOOP") {
                const el=now-loopStartTime; const pos=el%lDur;
                els.dispLoop.innerText=`# ${Math.floor(el/lDur)+1}`;
                if(c.hasBridge) {
                    const rem=c.junctionPoint-pos;
                    els.dispLimit.innerText=(rem>0)?formatTime(rem):"PASSED";
                    els.dispLimit.className=(rem>0&&rem<10)?"text-4xl font-mono tabular-nums text-rose-500 font-bold animate-pulse":"text-4xl font-mono tabular-nums text-white";
                }
                els.dispRemain.innerText=formatTime(lDur-pos);
            } else {
                if(c.hasBridge) els.dispLimit.innerText="LOCKED";
                els.dispRemain.innerText=formatTime((currentPhase.includes("WAITING")?finishScheduledTime:finishScheduledTime+buffers[p+(currentPhase==="BRIDGE"?'bridge':'outro')].duration)-now);
            }
            requestAnimationFrame(updateDashboard);
        }
    </script>
</body>
</html>
